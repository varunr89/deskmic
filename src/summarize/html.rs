/// Convert an LLM-generated markdown summary into a well-formatted HTML email.
///
/// Handles the specific markdown subset used by our summaries:
/// - `##` and `###` headings
/// - `**bold**` inline formatting
/// - `- ` bullet lists (with `  - ` nested sublists)
/// - `---` horizontal rules
/// - Blank-line-separated paragraphs

/// Wrap the rendered body HTML in a complete email template.
pub fn markdown_to_html_email(markdown: &str, subject: &str, date_label: &str) -> String {
    let body_html = render_markdown_body(markdown);

    format!(
        r##"<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>{subject}</title>
<style>
  body {{
    margin: 0;
    padding: 0;
    background-color: #f4f4f7;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    color: #333;
    -webkit-text-size-adjust: 100%;
  }}
  .wrapper {{
    width: 100%;
    background-color: #f4f4f7;
    padding: 32px 0;
  }}
  .container {{
    max-width: 640px;
    margin: 0 auto;
    background: #ffffff;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 1px 4px rgba(0,0,0,0.08);
  }}
  .header {{
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
    padding: 28px 32px;
    text-align: center;
  }}
  .header h1 {{
    margin: 0;
    font-size: 20px;
    font-weight: 600;
    color: #ffffff;
    letter-spacing: 0.3px;
  }}
  .header .date {{
    margin: 6px 0 0;
    font-size: 13px;
    color: #a0b4d0;
  }}
  .body {{
    padding: 28px 32px 32px;
    line-height: 1.6;
    font-size: 15px;
  }}
  .body h2 {{
    font-size: 17px;
    font-weight: 700;
    color: #1a1a2e;
    margin: 28px 0 12px;
    padding-bottom: 6px;
    border-bottom: 2px solid #e8ecf1;
  }}
  .body h2:first-child {{
    margin-top: 0;
  }}
  .body h3 {{
    font-size: 15px;
    font-weight: 600;
    color: #2d3748;
    margin: 20px 0 8px;
  }}
  .body p {{
    margin: 0 0 12px;
  }}
  .body ul {{
    margin: 4px 0 12px;
    padding-left: 20px;
  }}
  .body ul ul {{
    margin: 4px 0 4px;
  }}
  .body li {{
    margin: 4px 0;
  }}
  .body strong {{
    color: #1a1a2e;
  }}
  .body hr {{
    border: none;
    border-top: 1px solid #e8ecf1;
    margin: 24px 0;
  }}
  .footer {{
    padding: 16px 32px;
    text-align: center;
    font-size: 11px;
    color: #8898aa;
    background: #f9fafb;
    border-top: 1px solid #eef0f3;
  }}
  @media only screen and (max-width: 680px) {{
    .container {{ margin: 0 12px; }}
    .header, .body, .footer {{ padding-left: 20px; padding-right: 20px; }}
  }}
</style>
</head>
<body>
<div class="wrapper">
  <div class="container">
    <div class="header">
      <h1>{subject}</h1>
      <div class="date">{date_label}</div>
    </div>
    <div class="body">
{body_html}
    </div>
    <div class="footer">
      Generated by deskmic &middot; automated voice transcript summary
    </div>
  </div>
</div>
</body>
</html>"##,
        subject = escape_html(subject),
        date_label = escape_html(date_label),
        body_html = body_html,
    )
}

/// Render markdown body text into HTML fragments.
fn render_markdown_body(markdown: &str) -> String {
    let mut html = String::new();
    let lines: Vec<&str> = markdown.lines().collect();
    let mut i = 0;

    while i < lines.len() {
        let line = lines[i];
        let trimmed = line.trim();

        // Blank line — skip (paragraph gaps handled by block logic)
        if trimmed.is_empty() {
            i += 1;
            continue;
        }

        // Horizontal rule
        if trimmed == "---" || trimmed == "***" || trimmed == "___" {
            html.push_str("      <hr>\n");
            i += 1;
            continue;
        }

        // Heading: ## or ###
        if let Some(rest) = trimmed.strip_prefix("### ") {
            html.push_str(&format!(
                "      <h3>{}</h3>\n",
                inline_format(rest)
            ));
            i += 1;
            continue;
        }
        if let Some(rest) = trimmed.strip_prefix("## ") {
            html.push_str(&format!(
                "      <h2>{}</h2>\n",
                inline_format(rest)
            ));
            i += 1;
            continue;
        }
        if let Some(rest) = trimmed.strip_prefix("# ") {
            html.push_str(&format!(
                "      <h2>{}</h2>\n",
                inline_format(rest)
            ));
            i += 1;
            continue;
        }

        // Bullet list — collect all consecutive list items (top-level and nested)
        if is_list_item(line) {
            i = render_list(&lines, i, &mut html, 0);
            continue;
        }

        // Paragraph: bold-only lines (common in our summaries) or regular text
        let mut para_lines = Vec::new();
        while i < lines.len() {
            let l = lines[i].trim();
            if l.is_empty()
                || l.starts_with('#')
                || l == "---"
                || l == "***"
                || l == "___"
                || is_list_item(lines[i])
            {
                break;
            }
            para_lines.push(l);
            i += 1;
        }
        if !para_lines.is_empty() {
            let content = para_lines
                .iter()
                .map(|l| inline_format(l))
                .collect::<Vec<_>>()
                .join("<br>\n");
            html.push_str(&format!("      <p>{}</p>\n", content));
        }
    }

    html
}

/// Check whether a line is a list item (top-level or nested).
fn is_list_item(line: &str) -> bool {
    let trimmed = line.trim_start();
    trimmed.starts_with("- ") || trimmed.starts_with("* ")
}

/// Get the indentation level of a list item (number of leading spaces / 2).
fn list_indent(line: &str) -> usize {
    let spaces = line.len() - line.trim_start().len();
    spaces / 2
}

/// Render a markdown list starting at `start`, returning the next index to process.
fn render_list(lines: &[&str], start: usize, html: &mut String, depth: usize) -> usize {
    let pad = "      ".to_string() + &"  ".repeat(depth);
    html.push_str(&format!("{}<ul>\n", pad));

    let mut i = start;
    while i < lines.len() {
        let line = lines[i];
        if !is_list_item(line) && !line.trim().is_empty() {
            // Non-list, non-blank line ends the list
            break;
        }
        if line.trim().is_empty() {
            // Blank line within list — check if next line is still a list item
            if i + 1 < lines.len() && is_list_item(lines[i + 1]) {
                i += 1;
                continue;
            }
            break;
        }

        let indent = list_indent(line);
        if indent < depth {
            // Dedented — this item belongs to a parent list
            break;
        }
        if indent > depth {
            // Nested sublist — recurse
            i = render_list(lines, i, html, indent);
            continue;
        }

        // Same level — render the list item
        let text = line.trim_start().strip_prefix("- ").or_else(|| line.trim_start().strip_prefix("* ")).unwrap_or(line.trim());
        html.push_str(&format!("{}  <li>{}</li>\n", pad, inline_format(text)));
        i += 1;
    }

    html.push_str(&format!("{}</ul>\n", pad));
    i
}

/// Apply inline formatting: **bold** and escape HTML entities.
fn inline_format(text: &str) -> String {
    let escaped = escape_html(text);
    // Convert **bold** to <strong>bold</strong>
    let mut result = String::new();
    let mut chars = escaped.chars().peekable();
    while let Some(ch) = chars.next() {
        if ch == '*' && chars.peek() == Some(&'*') {
            chars.next(); // consume second *
            // Find closing **
            let mut bold_content = String::new();
            let mut found_close = false;
            while let Some(bc) = chars.next() {
                if bc == '*' && chars.peek() == Some(&'*') {
                    chars.next(); // consume second *
                    found_close = true;
                    break;
                }
                bold_content.push(bc);
            }
            if found_close {
                result.push_str(&format!("<strong>{}</strong>", bold_content));
            } else {
                // No closing ** found, output as-is
                result.push_str("**");
                result.push_str(&bold_content);
            }
        } else {
            result.push(ch);
        }
    }
    result
}

/// Escape HTML special characters.
fn escape_html(text: &str) -> String {
    text.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_escape_html() {
        assert_eq!(escape_html("<b>hi</b>"), "&lt;b&gt;hi&lt;/b&gt;");
        assert_eq!(escape_html("A & B"), "A &amp; B");
        assert_eq!(escape_html("\"quoted\""), "&quot;quoted&quot;");
    }

    #[test]
    fn test_inline_format_bold() {
        assert_eq!(
            inline_format("This is **bold** text"),
            "This is <strong>bold</strong> text"
        );
        assert_eq!(
            inline_format("**all bold**"),
            "<strong>all bold</strong>"
        );
        assert_eq!(
            inline_format("no formatting here"),
            "no formatting here"
        );
    }

    #[test]
    fn test_inline_format_bold_with_html() {
        assert_eq!(
            inline_format("**<script>alert(1)</script>**"),
            "<strong>&lt;script&gt;alert(1)&lt;/script&gt;</strong>"
        );
    }

    #[test]
    fn test_render_heading() {
        let md = "## Executive Summary";
        let html = render_markdown_body(md);
        assert!(html.contains("<h2>Executive Summary</h2>"));
    }

    #[test]
    fn test_render_h3() {
        let md = "### 12:00–12:59";
        let html = render_markdown_body(md);
        assert!(html.contains("<h3>"));
        assert!(html.contains("12:00"));
    }

    #[test]
    fn test_render_bullet_list() {
        let md = "- Item one\n- Item two\n- Item three";
        let html = render_markdown_body(md);
        assert!(html.contains("<ul>"));
        assert!(html.contains("<li>Item one</li>"));
        assert!(html.contains("<li>Item two</li>"));
        assert!(html.contains("<li>Item three</li>"));
        assert!(html.contains("</ul>"));
    }

    #[test]
    fn test_render_nested_list() {
        let md = "- Parent\n  - Child one\n  - Child two\n- Next parent";
        let html = render_markdown_body(md);
        // Should contain nested <ul>
        let ul_count = html.matches("<ul>").count();
        assert!(ul_count >= 2, "Expected nested ul, got:\n{}", html);
        assert!(html.contains("<li>Child one</li>"));
    }

    #[test]
    fn test_render_horizontal_rule() {
        let md = "Above\n\n---\n\nBelow";
        let html = render_markdown_body(md);
        assert!(html.contains("<hr>"));
    }

    #[test]
    fn test_render_paragraph() {
        let md = "This is a simple paragraph.";
        let html = render_markdown_body(md);
        assert!(html.contains("<p>This is a simple paragraph.</p>"));
    }

    #[test]
    fn test_full_email_template() {
        let md = "## Summary\n\n- Point one\n- Point two";
        let html = markdown_to_html_email(md, "Daily Summary", "2026-02-17");
        assert!(html.contains("<!DOCTYPE html>"));
        assert!(html.contains("Daily Summary"));
        assert!(html.contains("2026-02-17"));
        assert!(html.contains("<h2>Summary</h2>"));
        assert!(html.contains("<li>Point one</li>"));
        assert!(html.contains("Generated by deskmic"));
    }

    #[test]
    fn test_bold_in_list_items() {
        let md = "- **Key point**: Some details here";
        let html = render_markdown_body(md);
        assert!(html.contains("<strong>Key point</strong>"));
        assert!(html.contains("Some details here"));
    }
}
